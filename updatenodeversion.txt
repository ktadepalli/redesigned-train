#V1=======
import boto3
import os

def lambda_handler(event, context):
    eks_client = boto3.client("eks", region_name=os.environ.get("AWS_REGION", "ap-south-1"))
    
    cluster_name = os.environ.get("CLUSTER_NAME", "my-eks-cluster")   # set in Lambda env vars
    nodegroup_name = os.environ.get("NODEGROUP_NAME", "my-node-group")
    launch_template_name = os.environ.get("LAUNCH_TEMPLATE_NAME", "my-launch-template")
    target_lt_version = os.environ.get("TARGET_LT_VERSION", "48")     # Launch Template version
    
    try:
        response = eks_client.update_nodegroup_version(
            clusterName=cluster_name,
            nodegroupName=nodegroup_name,
            launchTemplate={
                "name": launch_template_name,
                "version": target_lt_version
            },
            updateConfig={
                "maxUnavailable": 1  # rolling update: 1 node at a time
            }
        )
        
        return {
            "statusCode": 200,
            "body": {
                "message": "EKS Node Group Launch Template update initiated",
                "updateId": response["update"]["id"],
                "status": response["update"]["status"]
            }
        }
    
    except Exception as e:
        return {
            "statusCode": 500,
            "body": {"error": str(e)}
        }

#v2==================
import boto3
import time
from botocore.exceptions import ClientError

def lambda_handler(event, context):
    """
    AWS Lambda function to update an EKS node group version with rolling update strategy.
    
    Expects event input in the format:
    {
        "cluster_name": "your-cluster-name",
        "nodegroup_name": "your-nodegroup-name",
        "desired_version": "1.48",
        "max_unavailable": 1
    }
    
    You can also override these values with environment variables.
    """
    
    # Get parameters from event or environment variables
    cluster_name = event.get('cluster_name') 
    nodegroup_name = event.get('nodegroup_name')
    desired_version = event.get('desired_version', '1.48')
    max_unavailable = event.get('max_unavailable', 1)
    
    # Fallback to environment variables if not in event
    if not cluster_name:
        cluster_name = os.environ.get('CLUSTER_NAME')
    if not nodegroup_name:
        nodegroup_name = os.environ.get('NODEGROUP_NAME')
    if not desired_version:
        desired_version = os.environ.get('DESIRED_VERSION', '1.48')
    if not max_unavailable:
        max_unavailable = int(os.environ.get('MAX_UNAVAILABLE', 1))
    
    # Validate required parameters
    if not all([cluster_name, nodegroup_name]):
        return {
            'statusCode': 400,
            'body': 'Missing required parameters: cluster_name and nodegroup_name must be provided'
        }
    
    eks_client = boto3.client('eks')
    
    try:
        # Check current node group status
        print(f"Checking current status of node group '{nodegroup_name}' in cluster '{cluster_name}'...")
        response = eks_client.describe_nodegroup(
            clusterName=cluster_name,
            nodegroupName=nodegroup_name
        )
        
        current_status = response['nodegroup']['status']
        current_version = response['nodegroup']['version']
        print(f"Current version: {current_version}, Status: {current_status}")
        
        if current_status != 'ACTIVE':
            error_msg = f"Node group is not in ACTIVE state. Current state: {current_status}. Aborting."
            print(error_msg)
            return {
                'statusCode': 400,
                'body': error_msg
            }
        
        if current_version == desired_version:
            message = f"Node group is already at version {desired_version}. No update needed."
            print(message)
            return {
                'statusCode': 200,
                'body': message
            }
        
        # Update node group version
        print(f"Updating node group '{nodegroup_name}' to version {desired_version}...")
        response = eks_client.update_nodegroup_version(
            clusterName=cluster_name,
            nodegroupName=nodegroup_name,
            version=desired_version,
            force=True,
            updateConfig={
                'maxUnavailable': max_unavailable,
                'type': 'RollingUpdate'
            }
        )
        
        update_id = response['update']['id']
        print(f"Update started. Update ID: {update_id}")
        
        # Wait for the update to complete (with timeout)
        timeout_seconds = 3600  # 1 hour timeout
        start_time = time.time()
        
        print("Waiting for update to complete...")
        while True:
            # Check timeout
            if time.time() - start_time > timeout_seconds:
                raise TimeoutError("Update timed out after 1 hour")
            
            response = eks_client.describe_nodegroup(
                clusterName=cluster_name,
                nodegroupName=nodegroup_name
            )
            
            status = response['nodegroup']['status']
            update_status = response['nodegroup'].get('updateStatus', 'No update in progress')
            
            print(f"Current status: {status}, Update status: {update_status}")
            
            if status == 'ACTIVE' and update_status == 'Successful':
                message = "Update completed successfully!"
                print(message)
                return {
                    'statusCode': 200,
                    'body': message,
                    'updateId': update_id
                }
            elif status == 'DEGRADED' or update_status == 'Failed':
                error_msg = "Update failed or node group is degraded. Check AWS console for details."
                print(error_msg)
                return {
                    'statusCode': 500,
                    'body': error_msg,
                    'updateId': update_id
                }
            elif update_status == 'InProgress':
                # Still in progress, wait before checking again
                time.sleep(30)
            else:
                # Handle other statuses
                time.sleep(30)
                
    except ClientError as e:
        error_msg = f"AWS API error occurred: {e.response['Error']['Message']}"
        print(error_msg)
        return {
            'statusCode': 500,
            'body': error_msg
        }
    except TimeoutError as e:
        error_msg = str(e)
        print(error_msg)
        return {
            'statusCode': 504,
            'body': error_msg
        }
    except Exception as e:
        error_msg = f"Unexpected error: {str(e)}"
        print(error_msg)
        return {
            'statusCode': 500,
            'body': error_msg
        }

# For local testing (if needed)
if __name__ == "__main__":
    test_event = {
        "cluster_name": "your-test-cluster",
        "nodegroup_name": "your-test-nodegroup",
        "desired_version": "1.48",
        "max_unavailable": 1
    }
    lambda_handler(test_event, None)

#v3=== from local
import boto3

# Initialize EKS client
eks_client = boto3.client("eks", region_name="ap-south-1")  # change region if needed

# Variables
cluster_name = "my-eks-cluster"   # Replace with your cluster name
nodegroup_name = "my-node-group"  # Replace with your node group name
target_version = "48"             # Replace with your required version

try:
    response = eks_client.update_nodegroup_version(
        clusterName=cluster_name,
        nodegroupName=nodegroup_name,
        version=target_version,
        updateConfig={
            "maxUnavailable": 1,  # rolling update: only 1 node unavailable at a time
        }
    )

    print("Update started successfully!")
    print("Update ID:", response["update"]["id"])
    print("Status:", response["update"]["status"])

except Exception as e:
    print("Error while updating node group:", str(e))


#V5=======
import boto3
import os
import time
from botocore.exceptions import ClientError

def lambda_handler(event, context):
    """
    AWS Lambda function to update an EKS node group by changing Launch Template version.
    
    Expects event input in the format:
    {
        "cluster_name": "your-cluster-name",
        "nodegroup_name": "your-nodegroup-name",
        "launch_template_version": "48",
        "max_unavailable": 1,
        "max_unavailable_percentage": 50
    }
    
    You can also override these values with environment variables.
    """
    
    # Get parameters from event or environment variables
    cluster_name = event.get('cluster_name') 
    nodegroup_name = event.get('nodegroup_name')
    launch_template_version = event.get('launch_template_version', '48')
    max_unavailable = event.get('max_unavailable')
    max_unavailable_percentage = event.get('max_unavailable_percentage', 50)
    
    # Fallback to environment variables if not in event
    if not cluster_name:
        cluster_name = os.environ.get('CLUSTER_NAME')
    if not nodegroup_name:
        nodegroup_name = os.environ.get('NODEGROUP_NAME')
    if not launch_template_version:
        launch_template_version = os.environ.get('LAUNCH_TEMPLATE_VERSION', '48')
    if max_unavailable is None:
        max_unavailable = os.environ.get('MAX_UNAVAILABLE')
    if not max_unavailable_percentage:
        max_unavailable_percentage = int(os.environ.get('MAX_UNAVAILABLE_PERCENTAGE', 50))
    
    # Validate required parameters
    if not all([cluster_name, nodegroup_name]):
        return {
            'statusCode': 400,
            'body': 'Missing required parameters: cluster_name and nodegroup_name must be provided'
        }
    
    eks_client = boto3.client('eks')
    
    try:
        # First, get the current node group configuration to extract the Launch Template ID
        print(f"Getting current configuration for node group '{nodegroup_name}'...")
        describe_response = eks_client.describe_nodegroup(
            clusterName=cluster_name,
            nodegroupName=nodegroup_name
        )
        
        current_status = describe_response['nodegroup']['status']
        print(f"Current node group status: {current_status}")
        
        if current_status != 'ACTIVE':
            error_msg = f"Node group is not in ACTIVE state. Current state: {current_status}. Aborting."
            print(error_msg)
            return {
                'statusCode': 400,
                'body': error_msg
            }
        
        # Extract Launch Template information
        launch_template = describe_response['nodegroup'].get('launchTemplate')
        if not launch_template:
            error_msg = "Node group is not using a Launch Template. This function only supports Launch Template updates."
            print(error_msg)
            return {
                'statusCode': 400,
                'body': error_msg
            }
        
        current_launch_template_id = launch_template['id']
        current_launch_template_version = launch_template.get('version', 'Unknown')
        
        print(f"Current Launch Template: {current_launch_template_id}, Version: {current_launch_template_version}")
        print(f"Desired new version: {launch_template_version}")
        
        if current_launch_template_version == launch_template_version:
            message = f"Node group is already using Launch Template version {launch_template_version}. No update needed."
            print(message)
            return {
                'statusCode': 200,
                'body': message
            }
        
        # Build the update config
        update_config = {}
        if max_unavailable is not None:
            update_config['maxUnavailable'] = int(max_unavailable)
        if max_unavailable_percentage is not None:
            update_config['maxUnavailablePercentage'] = int(max_unavailable_percentage)
        
        # Set update type to RollingUpdate if any update config is provided
        if update_config:
            update_config['type'] = 'RollingUpdate'
        
        # Update node group with new Launch Template version
        print(f"Updating node group '{nodegroup_name}' to use Launch Template version {launch_template_version}...")
        
        # Prepare the update parameters
        update_params = {
            'clusterName': cluster_name,
            'nodegroupName': nodegroup_name,
            'launchTemplate': {
                'version': launch_template_version,
                'id': current_launch_template_id
            }
        }
        
        # Only add updateConfig if we have rolling update configuration
        if update_config:
            update_params['updateConfig'] = update_config
        
        update_response = eks_client.update_nodegroup_config(**update_params)
        
        update_id = update_response['update']['id']
        print(f"Update started. Update ID: {update_id}")
        print(f"Update config: {update_config}")
        
        # Wait for the update to complete (with timeout)
        timeout_seconds = 3600  # 1 hour timeout
        start_time = time.time()
        max_attempts = 120  # Maximum number of checks (30-second intervals)
        attempts = 0
        
        print("Waiting for update to complete...")
        while attempts < max_attempts:
            # Check timeout
            if time.time() - start_time > timeout_seconds:
                raise TimeoutError("Update timed out after 1 hour")
            
            response = eks_client.describe_nodegroup(
                clusterName=cluster_name,
                nodegroupName=nodegroup_name
            )
            
            status = response['nodegroup']['status']
            update_status = response['nodegroup'].get('updateStatus', 'No update in progress')
            
            print(f"Current status: {status}, Update status: {update_status}")
            
            if status == 'ACTIVE' and update_status == 'Successful':
                # Verify the new Launch Template version is active
                current_lt = response['nodegroup'].get('launchTemplate', {})
                current_lt_version = current_lt.get('version', 'Unknown')
                
                if current_lt_version == launch_template_version:
                    message = f"Update completed successfully! Now using Launch Template version {launch_template_version}"
                    print(message)
                    return {
                        'statusCode': 200,
                        'body': message,
                        'updateId': update_id,
                        'newLaunchTemplateVersion': current_lt_version
                    }
                else:
                    message = f"Update completed but version mismatch. Expected: {launch_template_version}, Actual: {current_lt_version}"
                    print(message)
                    return {
                        'statusCode': 200,
                        'body': message,
                        'updateId': update_id,
                        'expectedVersion': launch_template_version,
                        'actualVersion': current_lt_version
                    }
            elif status == 'DEGRADED' or update_status == 'Failed':
                error_msg = "Update failed or node group is degraded. Check AWS console for details."
                print(error_msg)
                return {
                    'statusCode': 500,
                    'body': error_msg,
                    'updateId': update_id
                }
            
            # Still in progress, wait before checking again
            time.sleep(30)
            attempts += 1
            
        # If we reach here, the update took too long
        raise TimeoutError("Update did not complete within the expected time")
                
    except ClientError as e:
        error_msg = f"AWS API error occurred: {e.response['Error']['Message']}"
        print(error_msg)
        return {
            'statusCode': 500,
            'body': error_msg
        }
    except TimeoutError as e:
        error_msg = str(e)
        print(error_msg)
        return {
            'statusCode': 504,
            'body': error_msg
        }
    except Exception as e:
        error_msg = f"Unexpected error: {str(e)}"
        print(error_msg)
        return {
            'statusCode': 500,
            'body': error_msg
        }

# For local testing (if needed)
if __name__ == "__main__":
    test_event = {
        "cluster_name": "your-test-cluster",
        "nodegroup_name": "your-test-nodegroup",
        "launch_template_version": "48",
        "max_unavailable": 1
    }
    result = lambda_handler(test_event, None)
    print(result)
#V6==============

import boto3
import json
from botocore.exceptions import ClientError

def lambda_handler(event, context):
    """
    Simple Lambda to update EKS node group Launch Template version
    """
    try:
        # Parse input
        cluster_name = event.get('cluster_name', 'your-cluster-name')
        nodegroup_name = event.get('nodegroup_name', 'your-nodegroup-name')
        launch_template_version = event.get('launch_template_version', '48')
        
        eks_client = boto3.client('eks')
        
        print(f"Updating {nodegroup_name} to use Launch Template version {launch_template_version}")
        
        # First, get current launch template ID
        response = eks_client.describe_nodegroup(
            clusterName=cluster_name,
            nodegroupName=nodegroup_name
        )
        
        launch_template = response['nodegroup']['launchTemplate']
        launch_template_id = launch_template['id']
        
        print(f"Current Launch Template: {launch_template_id}, Version: {launch_template.get('version', 'Unknown')}")
        
        # Update the node group version
        response = eks_client.update_nodegroup_version(
            clusterName=cluster_name,
            nodegroupName=nodegroup_name,
            launchTemplate={
                'id': launch_template_id,
                'version': launch_template_version
            },
            # Remove updateConfig if it causes issues, or use correct structure
            force=False
        )
        
        update_id = response['update']['id']
        
        return {
            'statusCode': 200,
            'body': f"Update started successfully! Update ID: {update_id}",
            'updateId': update_id
        }
        
    except ClientError as e:
        error_message = e.response['Error']['Message']
        print(f"AWS Error: {error_message}")
        return {
            'statusCode': 500,
            'body': f"AWS API Error: {error_message}"
        }
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        return {
            'statusCode': 500,
            'body': f"Unexpected error: {str(e)}"
        }

# Test event for local testing
test_event = {
    "cluster_name": "your-cluster-name",
    "nodegroup_name": "your-nodegroup-name",
    "launch_template_version": "48"
}

# Uncomment for local testing
# print(lambda_handler(test_event, None))

#V7==========

import boto3
import json
from botocore.exceptions import ClientError

def lambda_handler(event, context):
    """
    Troubleshooting function for EKS node group Launch Template updates
    """
    cluster_name = event['cluster_name']
    nodegroup_name = event['nodegroup_name']
    launch_template_version = event['launch_template_version']
    
    eks = boto3.client('eks')
    ec2 = boto3.client('ec2')
    
    try:
        # 1. Get node group details
        print("1. Getting node group details...")
        nodegroup_info = eks.describe_nodegroup(
            clusterName=cluster_name,
            nodegroupName=nodegroup_name
        )
        
        lt_id = nodegroup_info['nodegroup']['launchTemplate']['id']
        current_version = nodegroup_info['nodegroup']['launchTemplate'].get('version', 'Unknown')
        node_role = nodegroup_info['nodegroup'].get('nodeRole', 'Unknown')
        
        print(f"   Current LT: {lt_id}, Version: {current_version}")
        print(f"   Node IAM Role: {node_role}")
        
        # 2. Check Launch Template permissions
        print("2. Checking Launch Template permissions...")
        lt_details = ec2.describe_launch_template_versions(
            LaunchTemplateId=lt_id,
            Versions=[launch_template_version]
        )
        
        lt_version_info = lt_details['LaunchTemplateVersions'][0]
        lt_data = lt_version_info['LaunchTemplateData']
        
        print(f"   LT Version {launch_template_version} exists: Yes")
        
        # 3. Check IAM instance profile in Launch Template
        iam_profile = lt_data.get('IamInstanceProfile', {})
        print(f"   IAM Instance Profile: {iam_profile.get('Arn', 'Not specified')}")
        
        # 4. Check security groups
        security_groups = lt_data.get('SecurityGroupIds', [])
        print(f"   Security Groups: {security_groups}")
        
        # 5. Check subnet availability
        subnets = nodegroup_info['nodegroup'].get('subnets', [])
        print(f"   Subnets: {subnets}")
        
        # 6. Try the update
        print("6. Attempting update...")
        response = eks.update_nodegroup_version(
            clusterName=cluster_name,
            nodegroupName=nodegroup_name,
            launchTemplate={
                'id': lt_id,
                'version': launch_template_version
            },
            force=True  # Force update if previous update failed
        )
        
        return {
            'statusCode': 200,
            'body': f"Update started successfully! Update ID: {response['update']['id']}",
            'updateId': response['update']['id']
        }
        
    except ClientError as e:
        error_code = e.response['Error']['Code']
        error_message = e.response['Error']['Message']
        
        print(f"AWS Error ({error_code}): {error_message}")
        
        # Common error handling
        if "UnauthorizedOperation" in error_message or "AccessDenied" in error_message:
            suggestion = "Check IAM permissions for the node role and ensure Launch Template permissions are correct"
        elif "InvalidParameter" in error_message:
            suggestion = "Verify Launch Template version exists and parameters are valid"
        elif "InsufficientInstanceCapacity" in error_message:
            suggestion = "Try different instance type or availability zone"
        else:
            suggestion = "Check CloudTrail logs for detailed error information"
        
        return {
            'statusCode': 500,
            'body': f"Error: {error_message}. Suggestion: {suggestion}",
            'errorCode': error_code
        }
    
    except Exception as e:
        return {
            'statusCode': 500,
            'body': f"Unexpected error: {str(e)}"
        }

# Test event
test_event = {
    "cluster_name": "your-eks-cluster",
    "nodegroup_name": "your-node-group", 
    "launch_template_version": "48"
}
V8====

import boto3
import json

def lambda_handler(event, context):
    """
    Fixes Launch Template by adding IAM instance profile and then updates node group
    """
    cluster_name = event['cluster_name']
    nodegroup_name = event['nodegroup_name']
    launch_template_version = event['launch_template_version']
    
    eks = boto3.client('eks')
    ec2 = boto3.client('ec2')
    
    try:
        # 1. Get node group details to find IAM role
        print("Getting node group IAM role...")
        nodegroup_info = eks.describe_nodegroup(
            clusterName=cluster_name,
            nodegroupName=nodegroup_name
        )
        
        node_role_arn = nodegroup_info['nodegroup']['nodeRole']
        # Extract role name from ARN
        node_role_name = node_role_arn.split('/')[-1]
        
        # 2. Get current Launch Template ID
        lt_id = nodegroup_info['nodegroup']['launchTemplate']['id']
        
        # 3. Get the specific Launch Template version details
        print(f"Getting Launch Template version {launch_template_version}...")
        lt_response = ec2.describe_launch_template_versions(
            LaunchTemplateId=lt_id,
            Versions=[launch_template_version]
        )
        
        lt_data = lt_response['LaunchTemplateVersions'][0]['LaunchTemplateData']
        
        # 4. Create a new Launch Template version with IAM instance profile
        print("Creating new Launch Template version with IAM instance profile...")
        
        # Create new version based on existing data but add IAM instance profile
        new_lt_data = lt_data.copy()
        new_lt_data['IamInstanceProfile'] = {
            'Name': node_role_name  # Use the IAM role name as instance profile name
        }
        
        # Remove None values that might cause API issues
        new_lt_data = {k: v for k, v in new_lt_data.items() if v is not None}
        
        # Create new Launch Template version
        new_version_response = ec2.create_launch_template_version(
            LaunchTemplateId=lt_id,
            LaunchTemplateData=new_lt_data,
            VersionDescription=f"Added IAM instance profile for EKS node group {nodegroup_name}"
        )
        
        new_version_number = str(new_version_response['LaunchTemplateVersion']['VersionNumber'])
        
        print(f"Created new Launch Template version: {new_version_number}")
        
        # 5. Now update node group with the fixed Launch Template version
        print("Updating node group with fixed Launch Template version...")
        update_response = eks.update_nodegroup_version(
            clusterName=cluster_name,
            nodegroupName=nodegroup_name,
            launchTemplate={
                'id': lt_id,
                'version': new_version_number
            }
        )
        
        return {
            'statusCode': 200,
            'body': f"Success! Created version {new_version_number} with IAM profile and started update: {update_response['update']['id']}",
            'newLaunchTemplateVersion': new_version_number,
            'updateId': update_response['update']['id']
        }
        
    except Exception as e:
        return {
            'statusCode': 500,
            'body': f"Error: {str(e)}"
        }

# Test event
test_event = {
    "cluster_name": "your-eks-cluster",
    "nodegroup_name": "your-node-group",
    "launch_template_version": "48"
}
